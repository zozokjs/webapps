Human 
-
Asian
-
Korean
-
JH

JH j = new JH():
하면 메모리에는 H,A,K,JH가 뜬다.
왜냐하면 JH는 H,A,K를 상속 받았으니까
다만 JK를 보고 있다. 
만약 H에 name = "가"라는 A에나, K에 다, JH에 라 있다면
j가 건드려진다.  왜냐하면 변수 명이 같으므로 위에 있는건 가려지므로 자기것만 건드린다. 만약 변수명이 name1,name2처럼 모두 다르다면 가나다라 모두 찾을 수 잇다.

메모리에 뜬건 뒤에가 결정(NEW 한거)
바라보는 타입은 앞에가 결정

Asian a= new Asian();
메모리에는 Asian과 Human이 뜬다.

Human j -= new JH()한다면
Human을 바라보고 있고 그 주소번지는 j가 기자고 있다. 이 상태에서 anmename이 있다면
name가 가 출력


오버라이딩 
Human에 sound(){  sysout(언어) }가 있는 상태에서
Asian에서 
class Asian()
{
	@Override
	void sound()
	{
	super.sound();
	sysout("한글");
	}
}한다면 [언어 한글]이 출력 될 것이다.
그러니까 추가하기 위해서 재정의도 한다.


~ 재정의하기 위해
JH에서 sound = "외계어"라고 한다
왜 굳이 재정의를 하는가. 새롭게 함수를 만들어도 되는데
바인딩 시키려고,  오버라이딩을 해야 바인딩을 따라서 오버라이드 된 메소드를 쓸 수 있으므로 

---------------
Korea a = new Asian()
바라볼 것이 메모리에 없으니까 오류

Korean a = new (Korea)Asian();
a.name() 하면, Korean이 가진 a가 메모리에 뜨지 않으므로 실행시 오류
new하는 것들은 실행 될 때 메모리에 뜬다.


H sound()
A
K sound()
JH sound() 

Human h  = new JH
h.sound하면 동적 바인딩으로 인해 JH가 가진 sound가 실행된다.JH가 마지막으로 오버라이딩 햇으므로.


A , JH 모두 sound() 오버라이딩 했는데 A의 sound를 읽으려면
JH에서 오버라이딩 안하거나
new Asian 혹은 new Korean한다.

동적바인딩 위해 인터페이스를만든다.
(같은 이름의 메서드가 있어야만 오버라이딩이 되고 그래서 동적 바인딩을 할 수 있기 때문에)

---------------------------------------------------------
상속은 통로 확보를 위해서(타입을 위해서) 쓴다. 
다중상속은 오버라이딩이 안 되기 떄문에 다중 상속 불가. 
오버라이딩 해야만 동적 바인딩(new한 것에 따라 메모리에 동적으로 뜬다)이 되기 때문이다.

규칙 : 오버라이드 해야 바인딩 가능.





